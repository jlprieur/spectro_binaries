/**************************************************************************
* simu_masss.c
*
* program to simulate histograms of 
* - masses of stars following a Salpeter's law
* - mass functions fm (to compare with those obtained experimentally 
* from spectroscopic orbits derived from CORAVEL observations)
*
* In a subsequent stage (not implemented here),
* those histograms will be compared with those obtained experimentally   
* with orbits dervived from CORAVEL observations, using statistical tests
* (see Appendix~B).
*
* JLP
* Version 27/03/2007
**************************************************************************/
#include "jlp_ftoc.h"

#define NN 100000
#define NBINS 10 
#define NN_TRUE 91 

int generate_masses_salpeter(double *mass, int nstars, double alpha, double kk);
int generate_masses_gauss(double *mass, int nstars, double mass_mean, 
                          double mass_sigma);
int save_histo_err_to_file(double *histo_values, double *histo_n, 
                           double *histo_n_err, int nbins, char *comments, 
                           char *histo_outfile);
int save_histo_to_file(double *histo_values, double *histo_n, int nbins,
                       char *comments, char *histo_outfile);
int compute_histo_mass(double *mass, int nstars, double *histo_mass, 
                       double *histo_mass_n, int nbins);
int compute_histo_fm1(double *mass, int nstars, double *histo_fm, 
                      double *histo_fm_n, double *histo_fm_n_err,
                      int nbins, double fm_min, double fm_max, char *list_outfile);
int compute_histo_fm2(double *mass, int nstars, double *histo_fm, 
                      double *histo_fm_n, int nbins, double fm_min, 
                      double fm_max, char *list_outfile, int save_list);
int compute_error_histo_fm(double *mass, int nstars, double *histo_fm, 
                           double *histo_fm_n, double *histo_fm_n_err, 
                           int nbins, double fm_min, double fm_max, 
                           char *list_outfile);
double random_inclination();


int main(int argc, char *argv[])
{
double kk, alpha, mass[NN], histo_mass[NBINS], histo_fm[NBINS], fm_max;
double mass_maxi, histo_mass_n[NBINS], histo_fm_n[NBINS]; 
double histo_fm_n_err[NBINS]; 
double mass_mean, mass_sigma;
int nbins = NBINS, nstars = NN;
int compute_mass_histogram = 0;
char histo_outfile[60], list_outfile[60], type[1], comments[80];
register int k;

/* To handle "runs simu_mass_and_fm (Salpeter's mass function)" */
for(k = 7; k > 0; k--) if(argc == k && argv[k-1][0] == '\0') argc = k-1;
if(argc != 4) {
  printf("Error, argc=%d \n Syntax is:\n", argc);
  printf("runs simu_mass_and_fm S,alpha out_histogram out_list\n");
  printf("or runs simu_mass_and_fm G,alpha out_histogram out_list\n");
  printf("Example: runs simu_mass_and_fm S,-0.3 histo_fm.dat simu_fm.dat\n");
  printf(" S = Salpeter, G = Gaussian distribution  \n");
  return(-1);
 }
sscanf(argv[1], "%c,%lf", &type[0], &alpha);
strcpy(histo_outfile, argv[2]);
strcpy(list_outfile, argv[3]);

printf("Output files: histo=%s list=%s\n", histo_outfile, list_outfile);

if(*type == 'S') {
/* Value corresponding to 1 is the maximum mass generated by the program:
* It should be 2. solar masses since the companion has a smaller mass
* than the primary */
  mass_maxi = 2.; 
  kk = (alpha + 1.) / pow(mass_maxi, (alpha + 1.));

  printf("type=%c kk=%.3f alpha=%.3f mass_maxi=%.3f kk=%.3f RAND_MAX=%d\n", 
        *type, kk, alpha, mass_maxi, kk, RAND_MAX);
  generate_masses_salpeter(mass, nstars, alpha, kk);
  sprintf(comments,"alpha=%.4f kk=%.2f nstars_true=%d", alpha, kk, NN_TRUE);
  } else {
  mass_mean = alpha;
  mass_sigma = 0.5;
  printf("type=%c mass_mean=%.3f mass_sigma=%.3f RAND_MAX=%d\n", 
        *type, mass_mean, mass_sigma, RAND_MAX);
  sprintf(comments,"mass_mean=%.4f mass_sigma=%.3f nstars_true=%d", 
          mass_mean, mass_sigma, NN_TRUE);
  generate_masses_gauss(mass, nstars, mass_mean, mass_sigma);
}

compute_mass_histogram = 0;
if(compute_mass_histogram) {
  compute_histo_mass(mass, nstars, histo_mass, histo_mass_n, nbins);
  save_histo_to_file(histo_mass, histo_mass_n, nbins, comments, histo_outfile);
} else {
/* To be equal to that of real data: (histo_fm_with_abt.dat)*/
  fm_max = 0.50;
  compute_histo_fm1(mass, nstars, histo_fm, histo_fm_n, histo_fm_n_err,
                    nbins, 0., fm_max, list_outfile);
  save_histo_err_to_file(histo_fm, histo_fm_n, histo_fm_n_err, nbins, 
                         comments, histo_outfile);
}

return(0);
}
/**************************************************************************
* Generate an array of randomly distributed masses according to
* Salpeter's law in M^\alpha
*
* p(m) = kk * m^{\alpha}
**************************************************************************/
int generate_masses_salpeter(double *mass, int nstars, double alpha, double kk)
{
double xx;
register int i;

/* Initialize random generator: */
srand(1);

for(i = 0; i < nstars; i++) {
  xx = (double)rand()/ (double)RAND_MAX;
  mass[i] = pow((alpha + 1.) * xx / kk, 1./(alpha + 1.)); 
#ifdef DEBUG
  if(i < 10) printf(" xx = %.2f, yy = %.2f \n", xx, mass[i]);
#endif
  }

return(0);
}
/**************************************************************************
* Save histogram to file
*
**************************************************************************/
int save_histo_to_file(double *histo_values, double *histo_n, int nbins, 
                       char *comments, char *histo_outfile)
{
FILE *fp;
register int i;

if((fp = fopen(histo_outfile, "w")) == NULL) {
  fprintf(stderr, "save_histo_to_file/Error opening %s \n", histo_outfile);
  return(-1);
  }

/* First line with comments */
  fprintf(fp,"%%%% %s\n", comments);

for(i = 0; i < nbins; i++) {
  fprintf(fp,"%f %f\n", histo_values[i], histo_n[i]);
  }

fclose(fp);
return(0);
}
/**************************************************************************
* Save histogram and errors to file
*
**************************************************************************/
int save_histo_err_to_file(double *histo_values, double *histo_n, 
                           double *histo_n_err, int nbins, char *comments, 
                           char *histo_outfile)
{
FILE *fp;
register int i;

if((fp = fopen(histo_outfile, "w")) == NULL) {
  fprintf(stderr, "save_histo_err_to_file/Error opening %s \n", histo_outfile);
  return(-1);
  }

/* First line with comments */
  fprintf(fp,"%%%% %s\n", comments);

for(i = 0; i < nbins; i++) {
  fprintf(fp,"%f %f %2f\n", histo_values[i], histo_n[i], histo_n_err[i]);
  }

fclose(fp);
return(0);
}
/**************************************************************************
* Compute the histogram of input array mass[] 
*
* INPUT:
*  mass: input array to be studied
*  nstars: number of stars of input array
*  histo_mass: histogram of masses (value)
*  histo_mass_n: histogram of masses (number of values)
*  nbins: number of bins of the histogram 
*
**************************************************************************/
int compute_histo_mass(double *mass, int nstars, double *histo_mass, 
                       double *histo_mass_n, int nbins)
{
double step;
register int i, k;

/* Initialization of the histogram: */
step = 2. / (double)nbins;
for(k = 0; k < nbins; k++) { 
  histo_mass_n[k] = 0.;
  histo_mass[k] = (double)k * step;
  }

/* Computation of the histogram: */
for(i = 0; i < nstars; i++) { 
  k = mass[i] / step; 
  if(k >= 0 && k < nbins) histo_mass_n[k] += 1.0;
  }

return(0);
}
/**************************************************************************
* Generate a histogram of mass functions [i.e., f(m)]
* from an array of stellar masses
*
* INPUT:
*  mass: array of masses of stars
*  nstars: number of stars
*  fm_min, fm_max: lower and upper limits for computing the histogram
*
* OUTPUT:
*  histo_fm: histogram of mass functions [i.e., f(m)]
* 
**************************************************************************/
int compute_histo_fm1(double *mass, int nstars, double *histo_fm, 
                      double *histo_fm_n, double *histo_fm_n_err,
                      int nbins, double fm_min, double fm_max, char *list_outfile)
{
double m1, step, ssum; 
int save_list = 1;
register int k;

m1 = 2.0;
/* Average most statistically value of the inclination is 60 degrees:
*  sin i = 0.5 */

step = (fm_max - fm_min)/ (double)nbins;
for(k = 0; k < nbins; k++) histo_fm[k] = (double)k * step;

compute_histo_fm2(mass, nstars, histo_fm, histo_fm_n, nbins, fm_min, 
                 fm_max, list_outfile, save_list);

/* Normalization to NN_TRUE=90 stars (as in histo_fm_with_abt.dat) */
/* Normalization to NN_TRUE=61 stars (as in histo_fm.dat) */
/*
  ssum = 0.;
  for(k = 0; k < nbins; k++) ssum += histo_fm_n[k]; 
  printf(" Sum of the first %d bins is %f\n", nbins, ssum);
*/
  ssum = nstars;
  for(k = 0; k < nbins; k++) { 
       histo_fm_n[k] *= ((float)NN_TRUE / ssum); 
/* I add 0.5 step to be able to plot the histogram as a curve */
       histo_fm[k] += step / 2.;
       }

  compute_error_histo_fm(mass, nstars, histo_fm, histo_fm_n, 
                         histo_fm_n_err, nbins, fm_min, fm_max, list_outfile);
return(0);
}
/**************************************************************************
* Generate a histogram of mass functions [i.e., f(m)]
* from an array of stellar masses 
* (called by compute_histo_fm1 and compute_error_histo_fm)
*
* INPUT:
*  mass: array of masses of stars
*  nstars: number of stars
*  fm_min, fm_max: lower and upper limits for computing the histogram
*  histo_fm: value of the mass functions [i.e., f(m)]
*  list_outfile: name of output file to save the list of mass and fm values
*  save_list: flag set to one if the list has to be saved to a file
*
* OUTPUT:
*  histo_fm_n: histogram of mass functions, 
*              i.e. histo_fm_n[i] is the number of stars having 
*              the mass function between histo_fm[i-1] and histo_fm[i]
* 
**************************************************************************/
int compute_histo_fm2(double *mass, int nstars, double *histo_fm, 
                     double *histo_fm_n, int nbins, double fm_min, 
                     double fm_max, char *list_outfile, int save_list)
{
double m1, mu, sin3i, sini, step, fm, incl, sin15deg; 
register int i, k;
FILE *fp_list;

if(save_list) {
if((fp_list = fopen(list_outfile,"w")) == NULL) {
 fprintf(stderr,"compute_histo_fm2/Fatal error opening output file: %s\n",
         list_outfile);
 exit(-1);
 }
}

m1 = 2.0;
/* Average most statistically value of the inclination is 60 degrees:
*  sin i = 0.5 */

step = (fm_max - fm_min)/ (double)nbins;
for(k = 0; k < nbins; k++) histo_fm_n[k] = 0.;

/* sin (15 degrees): */
 sin15deg = sin(15. * PI / 180.);

/* Computation of the histogram: */
for(i = 0; i < nstars; i++) { 
  mu = mass[i] / m1;
/* Generate random inclinations: */
/* Truncate the inclination at 15 degrees 
 (No significant difference compared to no truncation)
*/
   do {
      incl = random_inclination();
      sini = sin(incl);
      } while (sini < sin15deg);
  sin3i = sini * sini * sini;
  fm = m1 * sin3i * mu * mu * mu / SQUARE(1. + mu);
  if(save_list) fprintf(fp_list,"%f %f\n", mass[i], fm);
  k = (fm - fm_min)/ step; 
  if(k >= 0 && k < nbins) histo_fm_n[k] += 1.;
  }

if(save_list) fclose(fp_list);

return(0);
}
/**************************************************************************
* Computes the standard error of an histogram of mass functions [i.e., f(m)]
* from an array of stellar masses
*
* INPUT:
*  mass: array of masses of stars
*  nstars: number of stars
*  fm_min, fm_max: lower and upper limits for computing the histogram
*
* OUTPUT:
*  histo_fm: histogram of mass functions [i.e., f(m)]
* 
**************************************************************************/
int compute_error_histo_fm(double *mass, int nstars, double *histo_fm, 
                           double *histo_fm_n, double *histo_fm_n_err, 
                           int nbins, double fm_min, double fm_max, 
                           char *list_outfile)
{
double **histo_fm_nn, ww, sum, sumsq, mean, sigma;
int nh, save_list = 0;
register int i, j;

nh = NN / NN_TRUE;
if(nh < 1){ 
 fprintf(stderr, "compute_error_histo_fm/Fatal error: nh=%d (NN=%d NN_TRUE=%d)\n",
                   nh, NN, NN_TRUE);
 exit(-1);
 }

histo_fm_nn = (double **)malloc(nh * sizeof(double*));
for(i = 0; i < nh; i++) {
  histo_fm_nn[i] = (double *)malloc(NN_TRUE * sizeof(double));
  }

for(i = 0; i < nh; i++) {
  compute_histo_fm2(&(mass[i*NN_TRUE]), NN_TRUE, histo_fm, histo_fm_nn[i], 
                    nbins, fm_min, fm_max, list_outfile, save_list);
  }

for(j = 0; j < nbins; j++) {
  sum = 0.;
  sumsq = 0.;
  for(i = 0; i < nh; i++) {
    ww = histo_fm_nn[i][j];
    sum += ww; 
    sumsq += ww * ww; 
    }
  mean = sum /(float)nh;
  sigma = (sumsq / (float)nh) - (mean * mean);
  if(sigma > 0) sigma = sqrt(sigma);
  else sigma = 0.;
  histo_fm_n_err[j] = sigma;
/* Compare histogram computed with many (=NN) stars and its estimation
* with the mean of many histograms with fewer (=NN_TRUE) stars: */
  printf("histo(%d stars)=%.4f mean(%d x %d stars)=%.4f sigma=%.4f\n", 
          NN, histo_fm_n[j], nh, NN_TRUE, mean, sigma);
  }


for(i = 0; i < nh; i++) free(histo_fm_nn[i]); 
free(histo_fm_nn);
return(0);
}
/**************************************************************************
* Generate random inclination values
* the inclination of a system is defined as the angle betwen
* the line of sight and the axis perpendicular to the plane of the orbit
*
**************************************************************************/
double random_inclination()
{
double theta, phi, ww, incl, cos_incl;

/* Random phi and theta: */

/* theta: angle between Ox and OM', where M' is the projection of M onto
*         the plane (0x, Oy)
*  theta is uniform in the interval [0, 2 PI]
*/
theta = 2. * PI * (double)rand() / (double)RAND_MAX;

/*  phi: angle between OM' and OM, where M' is the projection of M onto
*         the plane (0x, Oy)
*  the probability of phi in the interval [0, PI] is proportional to sin(phi)
*  (since it is proportional to the area of the ring on the sphere of equal phi)
*  hence prob(phi) = 1/2 sin(phi)
*/
ww =  2. * ((double)rand() / (double)RAND_MAX) - 1.;
phi = acos(ww);

cos_incl = sin(phi) * cos(theta);
incl = acos(cos_incl);

return(incl);
}
/**************************************************************************
* Generate an array of randomly distributed masses according to
* a Gaussian probability density: 
*
* p(m) = (kk/ sqrt{2 \pi})  * exp( - m^2 / (2 \sigma)}
**************************************************************************/
int generate_masses_gauss(double *mass, int nstars, double mass_mean, 
                          double mass_sigma)
{
float xx;
register int i;

/* Initialize random generator: */
srand(1);

for(i = 0; i < nstars; i++) {
  JLP_RANDOM_GAUSS(&xx);
  mass[i] = xx * mass_sigma + mass_mean; 
#ifdef DEBUG
  if(i < 10) printf(" xx = %.2f, yy = %.2f \n", xx, mass[i]);
#endif
  }

return(0);
}
